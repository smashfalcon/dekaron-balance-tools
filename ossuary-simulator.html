<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Ossuary Simulator</title>

  <!-- CDN for Chart.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

  <style>
    /* Discord-inspired dark theme */
    :root {
      --background: #2c2d31;
      --background-secondary: #36393f;
      --background-tertiary: #202225;
      --text-primary: #dcddde;
      --text-secondary: #b9bbbe;
      --text-muted: #72767d;
      --blurple: #5865f2;
      --red: #ed4245;
      --green: #3ba55c;
      --yellow: #faa61a;
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background);
      color: var(--text-primary);
      line-height: 1.6;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding:1rem;
    }
    h1, h2, h3 {
      margin-bottom:1rem;
      color: var(--text-primary);
    }
    .card {
      background-color: var(--background-secondary);
      border-radius: 8px;
      padding:1.5rem;
      margin-bottom:1.5rem;
      box-shadow:0 2px 10px rgba(0,0,0,0.2);
    }
    .grid {
      display:grid;
      gap:1.5rem;
    }
    .grid-2 {
      grid-template-columns:1fr;
    }
    @media(min-width:768px){
      .grid-2 {
        grid-template-columns: 1fr 1fr;
      }
    }
    input[type="number"]{
      background-color:#4f545c;
      color:var(--text-primary);
      border:none;
      padding:0.5rem;
      border-radius:4px;
      width:100%;
      margin-bottom:1rem;
    }
    button{
      background-color:var(--blurple);
      color:white;
      border:none;
      padding:0.5rem 1rem;
      border-radius:4px;
      cursor:pointer;
      transition:background-color 0.2s;
    }
    button:hover{
      background-color:#4752c4;
    }
    button:disabled{
      background-color: var(--text-muted);
      cursor:not-allowed;
    }
    label{
      display:block;
      margin-bottom:0.5rem;
      color:var(--text-secondary);
    }
    .form-group{
      margin-bottom:1rem;
    }
    .error{
      color:var(--red);
      margin-bottom:0.5rem;
      font-size:0.9rem;
    }
    table{
      width:100%;
      border-collapse:collapse;
    }
    th, td{
      padding:0.5rem;
      border:1px solid #555;
    }
    th{
      background-color: var(--background-tertiary);
    }
    tr:nth-child(even){
      background-color: rgba(255,255,255,0.05);
    }
    .chart-container{
      position:relative;
      height:350px;
      width:100%;
    }
    .text-right{ text-align:right; }
    .text-center{text-align:center;}
    .checkbox-container{
      display:flex;
      align-items:center;
      margin-bottom:1rem;
    }
    .checkbox-container input{
      margin-right:0.5rem;
      accent-color:var(--blurple);
    }

    /* Percentile boxes */
    .percentile-card{
      padding:1rem;
      border-radius:4px;
      border-width:2px;
      border-style:solid;
      margin-bottom:1rem;
    }
    .percentile-card.unlucky {
      background-color:rgba(237,66,69,0.1);
      border-color: var(--red);
    }
    .percentile-card.average {
      background-color:rgba(250,166,26,0.1);
      border-color: var(--yellow);
    }
    .percentile-card.lucky {
      background-color:rgba(59,165,92,0.1);
      border-color: var(--green);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Ossuary Simulator</h1>

    <!-- Simulation Configuration -->
    <div class="card">
      <h2>Simulation Configuration</h2>

      <label>Talisman Drop Rates (%)</label>
      <div class="grid grid-2" id="dropRatesInputs"></div>
      <div id="rateError" class="error"></div>
      <div id="totalRate" style="color:var(--text-secondary); margin-bottom:1rem;">
        Total: 100% (must equal 100%)
      </div>

      <div class="grid grid-2">
        <div class="form-group">
          <label for="numChests">Number of Chests per Player</label>
          <input type="number" id="numChests" min="1" max="1000" value="10"/>
        </div>
        <div class="form-group">
          <label for="numSimulations">Number of Simulated Players</label>
          <input type="number" id="numSimulations" min="1" max="10000" value="100"/>
        </div>
      </div>

      <div class="form-group">
        <label for="ossuaryPrice">Ossuary Price</label>
        <input type="number" id="ossuaryPrice" min="1" value="240"/>
      </div>

      <button id="runSimulation">Run Simulation</button>
    </div>

    <!-- Results: Expected vs Actual & Distribution -->
    <div class="grid grid-2">
      <div class="card">
        <h2>Expected vs. Actual Drop Rates</h2>
        <table>
          <thead>
            <tr>
              <th>Item</th>
              <th class="text-right">Expected %</th>
              <th class="text-right">Actual %</th>
              <th class="text-right">Avg per Player</th>
            </tr>
          </thead>
          <tbody id="dropRatesTable"></tbody>
        </table>
      </div>
      <div class="card">
        <h2>Distribution of Final Averages</h2>
        <div class="chart-container">
          <canvas id="distributionChart"></canvas>
        </div>
        <div style="text-align:center; color:var(--text-secondary); margin-top:0.5rem;">
          Average Talisman % after <span id="chestsCount">10</span> chests
        </div>
      </div>
    </div>

    <!-- Player Journey Analysis -->
    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
        <h2>Player Journey Analysis</h2>
        <div class="checkbox-container">
          <input type="checkbox" id="showPercentiles" checked/>
          <label for="showPercentiles">Show Luck Percentiles</label>
        </div>
      </div>

      <h3>Average Value Progression</h3>
      <div class="chart-container" style="margin-bottom:1rem;">
        <canvas id="journeyChart"></canvas>
      </div>

      <h3>Player Experience Insights</h3>
      <div class="grid grid-2" style="grid-template-columns:1fr 1fr 1fr; gap:1rem;">
        <!-- 3 percentile boxes (5th, 50th, 95th) -->
        <div class="percentile-card unlucky">
          <h4>Unlucky Players (5th percentile)</h4>
          <p>Final Average: <strong id="unluckyAvg">0%</strong></p>
        </div>
        <div class="percentile-card average">
          <h4>Average Players (50th percentile)</h4>
          <p>Final Average: <strong id="avgAvg">0%</strong></p>
        </div>
        <div class="percentile-card lucky">
          <h4>Lucky Players (95th percentile)</h4>
          <p>Final Average: <strong id="luckyAvg">0%</strong></p>
        </div>
      </div>
    </div>

    <!-- Ratio-based Effective Cost Table -->
    <div class="card">
      <h2>Effective Cost (Ratio-based)</h2>
      <table>
        <thead>
          <tr>
            <th>Talisman</th>
            <th class="text-right">Theoretical Cost</th>
            <th class="text-right">Empirical Cost</th>
          </tr>
        </thead>
        <tbody id="ratioCostTable"></tbody>
      </table>
    </div>
  </div>

  <script>
    const state={
      // default rates
      rates:{
        '+20% Talisman':50,
        '+25% Talisman':45,
        '+30% Talisman':4.9,
        '+50% Talisman':0.1
      },
      numChests:10,
      numSimulations:100,
      ossuaryPrice:240,
      items:[],
      simulationResults:null,
      showPercentiles:true,
      charts:{
        distribution:null,
        journey:null
      }
    };

    // DOM
    const els={
      dropRatesInputs: document.getElementById('dropRatesInputs'),
      totalRate: document.getElementById('totalRate'),
      rateError: document.getElementById('rateError'),
      numChests: document.getElementById('numChests'),
      numSimulations: document.getElementById('numSimulations'),
      ossuaryPrice: document.getElementById('ossuaryPrice'),
      runSimulation: document.getElementById('runSimulation'),
      dropRatesTable: document.getElementById('dropRatesTable'),
      distributionChart: document.getElementById('distributionChart'),
      journeyChart: document.getElementById('journeyChart'),
      showPercentiles: document.getElementById('showPercentiles'),
      chestsCount: document.getElementById('chestsCount'),
      // percentile boxes
      unluckyAvg: document.getElementById('unluckyAvg'),
      avgAvg: document.getElementById('avgAvg'),
      luckyAvg: document.getElementById('luckyAvg'),
      ratioCostTable: document.getElementById('ratioCostTable')
    };

    // 1) Drop Rate UI
    function initDropRateInputs(){
      els.dropRatesInputs.innerHTML='';
      for(const [nm,val] of Object.entries(state.rates)){
        const div=document.createElement('div');
        const lab=document.createElement('label');
        lab.textContent= nm;
        const inp=document.createElement('input');
        inp.type='number'; inp.min='0'; inp.max='100'; inp.step='0.1';
        inp.value= val;
        inp.addEventListener('input', e=>{
          state.rates[nm]= parseFloat(e.target.value);
          updateTotalRate();
        });
        div.appendChild(lab);
        div.appendChild(inp);
        els.dropRatesInputs.appendChild(div);
      }
      updateTotalRate();
    }
    function updateTotalRate(){
      const sum= Object.values(state.rates).reduce((a,b)=>a+b,0);
      els.totalRate.textContent=`Total: ${sum.toFixed(1)}% (must equal 100%)`;
      if(Math.abs(sum-100)>0.01){
        els.rateError.textContent=`Total must be 100%. Currently ${sum.toFixed(1)}%`;
        els.runSimulation.disabled=true;
      } else {
        els.rateError.textContent='';
        els.runSimulation.disabled=false;
      }
    }

    function ratesToItems(){
      state.items= Object.entries(state.rates).map(([name,val])=>{
        return {
          name,
          probability: val/100,
          value: parseInt(name.replace(/\D+/g,''))||0
        };
      });
    }

    // 2) Simulation with full journey
    function openChest(){
      const roll=Math.random();
      let cProb=0;
      for(const it of state.items){
        cProb+= it.probability;
        if(roll< cProb) return it;
      }
      return state.items[state.items.length-1];
    }
    function simulatePlayerJourney(numChests){
      const journey=[];
      const itemCounts={};
      state.items.forEach(it=> itemCounts[it.name]=0);
      let totalVal=0;

      for(let c=0; c<numChests; c++){
        const it=openChest();
        itemCounts[it.name]++;
        totalVal+= it.value;
        const runAvg= totalVal/(c+1);

        const chestData={
          chest:c+1,
          item: it.name,
          itemValue: it.value,
          runningAverage: runAvg
        };
        for(const nm in itemCounts){
          chestData[`count_${nm}`]= itemCounts[nm];
        }
        journey.push(chestData);
      }
      const finalAverage= journey[numChests-1].runningAverage;
      return {
        journey,
        finalAverage,
        itemCounts
      };
    }

    function runSimulation(){
      state.numChests= parseInt(els.numChests.value)||10;
      state.numSimulations= parseInt(els.numSimulations.value)||100;
      state.ossuaryPrice= parseFloat(els.ossuaryPrice.value)||240;
      els.chestsCount.textContent= state.numChests;

      ratesToItems();
      const allSimulations=[];
      const finalAverages=[];
      for(let i=0;i< state.numSimulations;i++){
        const sim= simulatePlayerJourney(state.numChests);
        allSimulations.push(sim);
        finalAverages.push(sim.finalAverage);
      }
      finalAverages.sort((a,b)=>a-b);

      // compute percentile journeys
      const pvals={5:null,50:null,95:null};
      for(const p of [5,50,95]){
        let idx=Math.floor((p/100)*finalAverages.length);
        if(idx>=finalAverages.length) idx=finalAverages.length-1;
        pvals[p]= finalAverages[idx];
      }
      const percentileJourneys={};
      [5,50,95].forEach(p=>{
        const target= pvals[p];
        let best= allSimulations[0];
        let bestDiff= Math.abs(best.finalAverage-target);
        for(const sim of allSimulations){
          const diff= Math.abs(sim.finalAverage- target);
          if(diff< bestDiff){
            best= sim;
            bestDiff= diff;
          }
        }
        percentileJourneys[p]= best.journey;
      });

      // average journey
      const averageJourney=[];
      for(let c=0;c< state.numChests;c++){
        let sumRunning=0;
        for(const sim of allSimulations){
          sumRunning+= sim.journey[c].runningAverage;
        }
        const avg= sumRunning/allSimulations.length;
        averageJourney.push({
          chest:c+1,
          runningAverage: avg
        });
      }

      state.simulationResults={
        allSimulations,
        finalAverages,
        percentileJourneys,
        averageJourney
      };
      updateDisplay();
    }

    // 3) Display updates
    function updateDisplay(){
      updateDropRatesTable();
      updateDistributionChart();
      updateJourneyChart();
      updatePercentileBoxes();
      updateRatioCostTable();
    }

    // (A) Drop Rates Table
    function updateDropRatesTable(){
      els.dropRatesTable.innerHTML='';
      const allSim= state.simulationResults.allSimulations;
      const totalChests= state.numChests* state.numSimulations;

      // sum item counts
      const sums={};
      state.items.forEach(it=> sums[it.name]=0);
      for(const sim of allSim){
        for(const nm in sim.itemCounts){
          sums[nm]+= sim.itemCounts[nm];
        }
      }

      // build table rows
      for(const it of state.items){
        const row=document.createElement('tr');
        const tdName=document.createElement('td'); tdName.textContent= it.name;
        const tdExp=document.createElement('td'); tdExp.className='text-right';
        tdExp.textContent= (it.probability*100).toFixed(2)+'%';
        const actual= (sums[it.name]/totalChests)*100;
        const tdAct=document.createElement('td'); tdAct.className='text-right';
        tdAct.textContent= actual.toFixed(2)+'%';
        const tdAvg=document.createElement('td'); tdAvg.className='text-right';
        tdAvg.textContent= (sums[it.name]/ state.numSimulations).toFixed(2);

        row.append(tdName, tdExp, tdAct, tdAvg);
        els.dropRatesTable.appendChild(row);
      }
    }

    // (B) Distribution of final averages
    function buildDistData(){
      const bucketSize=0.5;
      const buckets={};
      for(const val of state.simulationResults.finalAverages){
        const bk=Math.floor(val/bucketSize)*bucketSize;
        buckets[bk]=(buckets[bk]||0)+1;
      }
      const labels= Object.keys(buckets).map(k=>{
        const low= parseFloat(k).toFixed(1);
        const high=(parseFloat(k)+bucketSize).toFixed(1);
        return `${low}-${high}`;
      });
      const data= Object.values(buckets);
      return {labels,data};
    }
    function updateDistributionChart(){
      if(state.charts.distribution) state.charts.distribution.destroy();
      const {labels,data}= buildDistData();
      const ctx= els.distributionChart.getContext('2d');
      state.charts.distribution= new Chart(ctx,{
        type:'bar',
        data:{
          labels,
          datasets:[{
            label:'Number of Players',
            data,
            backgroundColor:'#5865f2'
          }]
        },
        options:{
          responsive:true,
          maintainAspectRatio:false,
          scales:{
            x:{
              grid:{color:'#555'},
              ticks:{color:'#b9bbbe'},
              title:{
                display:true,
                text:'Average Talisman %',
                color:'#b9bbbe'
              }
            },
            y:{
              grid:{color:'#555'},
              ticks:{color:'#b9bbbe'},
              title:{
                display:true,
                text:'Number of Players',
                color:'#b9bbbe'
              }
            }
          }
        }
      });
    }

    // (C) Journey chart with dynamic Y range
    function updateJourneyChart(){
      if(state.charts.journey) state.charts.journey.destroy();
      const ctx= els.journeyChart.getContext('2d');

      // build data sets
      const dataSets=[];
      // mean line
      const meanData= state.simulationResults.averageJourney.map(pt=>({x:pt.chest,y:pt.runningAverage}));
      dataSets.push({
        label:'Mean (All Players)',
        data: meanData,
        borderColor:'#dcddde',
        backgroundColor:'#dcddde',
        borderWidth:2,
        tension:0.1,
        pointRadius:0
      });

      if(state.showPercentiles){
        const colors={5:'#ed4245',50:'#faa61a',95:'#3ba55c'};
        [5,50,95].forEach(p=>{
          const journey= state.simulationResults.percentileJourneys[p];
          if(!journey) return;
          let label= `${p}th Percentile`;
          if(p===5) label+=' (Unlucky)';
          if(p===50) label+=' (Average)';
          if(p===95) label+=' (Lucky)';
          const lineData= journey.map(ch=>({x:ch.chest,y: ch.runningAverage}));
          dataSets.push({
            label,
            data: lineData,
            borderColor: colors[p],
            backgroundColor: colors[p],
            borderWidth:2,
            tension:0.1,
            pointRadius:0
          });
        });
      }

      // figure out min/max Y
      let allY=[];
      for(const ds of dataSets){
        for(const pt of ds.data){
          allY.push(pt.y);
        }
      }
      if(allY.length<1) allY=[0,100];
      const minY= Math.min(...allY);
      const maxY= Math.max(...allY);
      const padding= (maxY-minY)*0.1 || 1;
      const chartMinY= minY - padding< 0? 0: minY - padding;
      const chartMaxY= maxY + padding;

      state.charts.journey= new Chart(ctx,{
        type:'line',
        data:{ datasets: dataSets },
        options:{
          responsive:true,
          maintainAspectRatio:false,
          scales:{
            x:{
              type:'linear',
              min:1,
              max: state.numChests,
              ticks:{color:'#b9bbbe'},
              grid:{color:'#555'},
              title:{
                display:true,
                text:'Number of Chests Opened',
                color:'#b9bbbe'
              }
            },
            y:{
              min: chartMinY,
              max: chartMaxY,
              ticks:{color:'#b9bbbe'},
              grid:{color:'#555'},
              title:{
                display:true,
                text:'Average Talisman %',
                color:'#b9bbbe'
              }
            }
          }
        }
      });
    }

    // (D) Percentile boxes (only final average)
    function updatePercentileBoxes(){
      const simRes= state.simulationResults;
      if(!simRes) return;

      const arr= simRes.finalAverages;
      const idx5= Math.floor(0.05*(arr.length-1));
      const idx50= Math.floor(0.50*(arr.length-1));
      const idx95= Math.floor(0.95*(arr.length-1));

      els.unluckyAvg.textContent= arr[idx5].toFixed(2)+'%';
      els.avgAvg.textContent= arr[idx50].toFixed(2)+'%';
      els.luckyAvg.textContent= arr[idx95].toFixed(2)+'%';
    }

    // (E) Ratio-based cost table
    function updateRatioCostTable(){
      const tb= els.ratioCostTable;
      tb.innerHTML='';

      // find baseline item
      let baseline= state.items[0];
      for(const it of state.items){
        if(it.probability> baseline.probability){
          baseline= it;
        }
      }

      // sum item counts
      const allSim= state.simulationResults.allSimulations;
      const itemCounts={};
      state.items.forEach(it=> itemCounts[it.name]=0);
      allSim.forEach(sim=>{
        for(const nm in sim.itemCounts){
          itemCounts[nm]+= sim.itemCounts[nm];
        }
      });
      const baselineCount= itemCounts[baseline.name]||0;
      const baselineProb= baseline.probability;

      // show all Talisman items
      const relevant= state.items.filter(it=> it.name.includes('Talisman'));
      relevant.forEach(it=>{
        const row=document.createElement('tr');
        const tdName=document.createElement('td');
        tdName.textContent= it.name;

        // theoretical ratio
        let ratioTheo= Infinity;
        if(baselineProb>0 && it.probability>0){
          ratioTheo= baselineProb/ it.probability;
        }
        const costTheo= isFinite(ratioTheo)
          ? state.ossuaryPrice* ratioTheo
          : Infinity;

        const tdTheo=document.createElement('td');
        tdTheo.className='text-right';
        tdTheo.textContent= isFinite(costTheo)? costTheo.toFixed(2): '∞';

        // empirical ratio
        const cItem= itemCounts[it.name]||0;
        let ratioEmp= Infinity;
        if(baselineCount>0 && cItem>0){
          ratioEmp= baselineCount/cItem;
        }
        const costEmp= isFinite(ratioEmp)
          ? state.ossuaryPrice* ratioEmp
          : Infinity;
        const tdEmp=document.createElement('td');
        tdEmp.className='text-right';
        tdEmp.textContent= isFinite(costEmp)? costEmp.toFixed(2):'∞';

        row.append(tdName, tdTheo, tdEmp);
        tb.appendChild(row);
      });
    }

    function attachEvents(){
      els.runSimulation.addEventListener('click', runSimulation);
      els.numChests.addEventListener('input',()=>state.numChests= parseInt(els.numChests.value)||10);
      els.numSimulations.addEventListener('input',()=>state.numSimulations= parseInt(els.numSimulations.value)||100);
      els.ossuaryPrice.addEventListener('input',()=>state.ossuaryPrice= parseFloat(els.ossuaryPrice.value)||240);
      els.showPercentiles.addEventListener('change',()=>{
        state.showPercentiles= els.showPercentiles.checked;
        if(state.simulationResults) updateJourneyChart();
      });
    }

    function init(){
      initDropRateInputs();
      attachEvents();
      runSimulation();
    }
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
